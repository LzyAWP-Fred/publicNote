#+TITLE: 计算机基础与面试准备 
* 算法
** 2/6
*** Data structure: 是一种特别的方式, 电脑里组织数据的方式, 所以能够更高效的使用
- Common data structure:
  - 线性数据结构
    - array 数组
      - int array[10]
    - stack 栈
      - 一段封闭, 只能从屁股开始存取
    - queue /q/ a list of data items 队列
      - 两端都能操作, 有点跟stack像
    - linked list 链表
      - 和array有点像, 他们真的佛珠一样连在一起

*** 打印array的元素
- time complexity = O(n)
- space complexity = O(n)
- 线性增长是n
- 花得时间是恒定的,OJ(1), 例如把array的size打印出来
- 什么时候是n^2

*** 复杂度
- 时间复杂度
- 空间复杂度: 运行这个算法需要多少内存O(n), 学术派 == 忽律
- auxiliary备用的 空间复杂度: 面试默认, 算法峰值消耗的内存, 不包括输入
#+BEGIN_SRC java
int [] array = new int[10];
for (int i = 0; i < array.length; i++){
    System.out.println(array[i]);
}
#+END_SRC
  - space complexity = O(1)
- 额外需要O(n)空间复杂度的例子?
  - 复制这个数组到另外一个数组
- 总结
  - 随着自变量增长, 复杂度线性增长的是O(n)
  - 随着自变量增长, 复杂度恒定的是O(1)

*** Selection Sort 选择排序
- 把没排好序的元素里, 选择最细的, 放在没排好的最左边
#+BEGIN_SRC java
step1: find global min, {-3, -1, 4, 7}, min: -3, => -3, {-1, 4, 7}
step2: find global min, -3, {-1, 4, 7}, min: -1, => -3, -1, {4,7}
step3: find global min, -3, -1, {4,7}, min: 4, => -3, -1, 4, {7}
step4: find global min done. 不找了, 做个优化 未排变已排
#+END_SRC

*** 讲解代码要点 / Selection Sort:
- 先讲你的assumption假设, eg. 升序,还是降. For this question, I will assume that.......
- 然后讲方法, 你点样去解决这个问题
- 要写注释comments
- 描述big-O 运行时间复杂度
- 说一下任何额外使用的数据结构并且讲下点解, eg hash table
- 提供问题的各个部分最优解 
#+BEGIN_SRC java
void SelectionSort(int a[], int n){
    int global, temp;
    // i是操作位置
    for (int i = 0, i < n-1; i++){
        global = i;
        for (int j = i +1; j < n; j++){
            if (a[j] < a[global]){
                global = j;
            }
        }
        // 交换最小值和目前的操作位置
        temp = a[i];
        a[i] = a[global];
        a[global] = temp;  
    }  
}
#+END_SRC
- 时间复杂度
  - 一个循环内嵌一个循环: i循环n-1次, j循环n-1次(1开始)
  - i = 0; j = 1, 2, 3... => n-1次
  - i = 1; j = 2, 3, 4... => n-2次
  - i = n-3; j = n-2, n-1 => 2次
  - i = n-2; j = n-1 => 1次
  - 和 = 复杂度 = 等差数列 = 1+2+3+...+n-1 = (1+n-1)(n-1)/2 = n(n-1)/2 => n^2 => O(n^2)

*** 面试变种题
- given an array stored in Stack1, how to sort the numbers by using additional two stacks
#+BEGIN_SRC java
stack1 : 4 1 3 
stack2 : 
stack3 :

// 自己建立个global_min, stack1最后的元素'3'复制到global_min
global_min = 3
stack1 : 4 1 3
stack2 : 
stack3 :

//移动'3'到stack2, 比较global_min与stack1最后一个元素, 如果更小就更新global_min
global_min = 3
stack1 : 4 1 
stack2 : 3
stack3 :

global_min = 1
stack1 : 4  
stack2 : 3 1
stack3 :

global_min = 1
stack1 :   
stack2 : 3 1 4
stack3 : 1

//移动stack2回stack1, 如果是global_min就忽略
global_min = 
stack1 : 4 3
stack2 :
stack3 : 1 

global_min = 3 
stack1 : 4
stack2 : 3 
stack3 : 1 

global_min = 3 
stack1 : 
stack2 : 3 4 
stack3 : 1 

global_min =  
stack1 : 4
stack2 :  
stack3 : 1 3

// 最后一个直接移动就可以了
global_min =  
stack1 : 
stack2 :  
stack3 : 1 3 4
#+END_SRC

- 用两个stack, 而不是3个. stack2当做结果stack, 需要一个隐形的隔板
#+BEGIN_SRC java
stack1 : 4 1 3 
stack2 : 

min = 3
stack1 : 4 1 3 
stack2 :

min = 3
stack1 : 4 1  
stack2 : 3

min = 1
stack1 :    
stack2 : 3 1 4

//不剪切复制和min相同的数回stack1, stack2留下了排好的东西, 隔板的原来
min = 1
stack1 : 4 3
stack2 : 1

min = 3
stack1 : 4 3
stack2 : 1

min = 3
stack1 :  
stack2 : 1 3 4
h
min = 3
stack1 : 4
stack2 : 1 3

min = 
stack1 : 4
stack2 : 1 3
#+END_SRC

*** 疑点
- 时间复杂度
- what are they good for 对...有益 , thorough /thero/ 全面地
** other
   
